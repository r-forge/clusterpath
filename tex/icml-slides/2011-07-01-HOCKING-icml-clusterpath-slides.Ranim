% -*- mode: noweb; noweb-code-mode: R-mode -*-
\documentclass{beamer}
    %tdh from http://stackoverflow.com/questions/2320776/remove-the-slide-count-from-beamer-footer
    \usetheme{Madrid}

      %#make sure to change this part, since it is predefined
      %\defbeamertemplate*{footline}{infolines theme}
      \setbeamertemplate{footline}
        {
      \leavevmode%
      \hbox{%
      \begin{beamercolorbox}[wd=.4\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
        \usebeamerfont{author in head/foot}\insertshortauthor (\insertshortinstitute)
      \end{beamercolorbox}%
      \begin{beamercolorbox}[wd=.4\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
        \usebeamerfont{title in head/foot}\insertshorttitle
      \end{beamercolorbox}%
      \begin{beamercolorbox}[wd=.2\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
        \usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em}

    %#turning the next line into a comment, erases the frame numbers
        %\insertframenumber{} / \inserttotalframenumber\hspace*{2ex} 

      \end{beamercolorbox}}%
      \vskip0pt%
    }


\newcommand{\minimize}[3]{
\begin{aligned}
&  \min_{#1} && #2\\
&  \text{subject to}&& #3
\end{aligned}
}


\usepackage{amsmath,amssymb}
\usepackage{hyperref}
%\usepackage{xypic}
\usepackage{tikz} 
\usepackage[nogin]{Sweave}
\SweaveOpts{width=5,height=3.25,keep.source=TRUE}

\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection]
  \end{frame}
}

\AtBeginSubsection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline}
    \tableofcontents[currentsection,currentsubsection]
  \end{frame}
}

\usepackage{graphicx}

\newcommand{\sign}{\operatorname{sign}}
\begin{document}

  \title[Clusterpath for hierarchical convex clustering]{
    Clusterpath: \\an algorithm for clustering using convex fusion penalties}
  \institute[INRIA Paris]{Sierra team --- INRIA Paris}
  \author[Toby Dylan Hocking \emph{et al.}]{Toby Dylan Hocking\\
{\small joint work with Armand Joulin, Francis Bach, and Jean-Philippe Vert}}
\date{1 July 2011}

\maketitle
\section[Outline]{}

\frame{\tableofcontents}

\newcommand{\framet}[2]{\frame{\frametitle{#1}
  \begin{itemize}
      #2
    \end{itemize}
}}

\newcommand{\picframe}[1]{
  \frame[plain]{
%    \includegraphics[width=\textwidth]{#1}
  }
}
\newcommand{\norm}[1]{|\!|#1|\!|}
\newcommand{\minof}[1]{
  \underset{#1}{\min}
}

\newcommand{\RR}{\mathbb R}

\section{Introduction: framing clustering as a convex optimization
  problem results in the clusterpath}

\begin{frame}
  \frametitle{Existing clustering methods have some drawbacks}
  \begin{itemize}
  \item Clustering: assign labels to points $X\in\RR^{n\times p}$.
  \item Classical methods: hierarchical, k-means, spectral, mixture
    models.
  \item K-means is not hierarchical: less interpretable. 
  \item K-means is not convex: no guarantees to find the global
    optimum.
    \item Our contributions:
  \begin{itemize}
  \item A new convex objective function for clustering.
  \item Interpretable, hierarchical clustering.
  \item Efficient algorithms.
  \item Clustering performance on par with spectral clustering.
  \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The clusterpath relaxes a hard fusion penalty}
  Look for a matrix $\alpha\in\RR^{n\times p}$ such that
  \begin{itemize}
  \item $\alpha_i \approx X_i$ for all $i$, and
  \item Some $\alpha_i$ and $\alpha_j$ are exactly equal:
  \end{itemize}
$$
  \minimize{
    \alpha\in\RR^{n\times p}}{
    \frac 1 2 ||\alpha-X||_F^2}{
    \sum_{i<j}1_{\alpha_i\neq\alpha_j} \leq t}
$$
\begin{itemize}
\item   This is non-convex, thus no guarantees to find global optimum.
\item We propose the following convex relaxation:
\end{itemize}
$$
\minimize{
    \alpha\in\RR^{n\times p}}{
    \frac 1 2 ||\alpha-X||_F^2}{
    \sum_{i<j}||\alpha_i-\alpha_j||_q \leq t}
$$
\end{frame}

\begin{frame} \frametitle{Geometric interpretation of penalty with identity
    weights}
    \begin{minipage}{2in}
      \begin{itemize}
      \item Let $X\in\RR^{3\times 2}$.
      \item $n=3$ points.
      \item $p=2$ dimensions.
      \item Approximate $X$ using $\alpha$: $ \min_\alpha||\alpha-X||^2_F $
      \item Constrain the total distance between every pair of points:
        $$\sum_{i<j}||\alpha_i-\alpha_j||_q \leq t$$
        (grey lines)
      \end{itemize}
  \end{minipage}
  \begin{minipage}{2.5in}
<<fig=FALSE,tikz=FALSE,echo=FALSE,results=hide>>=
library(clusterpath)
### Figure 1. geometric interpretation
set.seed(3)
x <- replicate(2,rnorm(3))
pts <- data.frame(alpha=x,row=1:nrow(x))
getlines <- function(x){
  require(foreach)
  N <- nrow(x)
  foreach(i=1:(N-1),.combine=rbind)%do%{
    foreach(j=(i+1):N,.combine=rbind)%do%{
      start <- x[i,]
      end <- x[j,]
      data.frame(start.1=start[1],end.1=end[1],start.2=start[2],end.2=end[2],
                 norm=factor(2))
    }
  }
}
getpolys <- function(alpha.df){
  W <- attr(alpha.df,"w")
  alpha <- alpha.df[,c("row",attr(alpha.df,"alphacolnames"))]
  clusters <- unique(round(alpha[,-1],6))
  N <- nrow(clusters)
  close <- function(u,v)sqrt(sum((v-u)^2))<1e-6
  equal <- function(u)apply(alpha[,-1],1,close,u)
  polys <- data.frame()
  ws <- data.frame()
  width <- data.frame()
  for(i in 1:(N-1))for(j in (i+1):N){
    ci <- as.matrix(clusters[i,])
    cj <- as.matrix(clusters[j,])
    m <- (ci[2]-cj[2])/(ci[1]-cj[1])
    rects <- expand.grid(i=alpha[equal(ci),"row"],j=alpha[equal(cj),"row"])
    rects$wij <- W[as.matrix(rects)]
    total <- sum(rects$wij)
    ## this is the horizontal displacement from ci
    intercept <- ci[2]-ci[1]*m
    int2 <- ci[1]/m+ci[2]
    m2 <- -1/m
    iperp <- function(x)m2*(x-ci[1])+ci[2]
    jperp <- function(x)m2*(x-cj[1])+cj[2]
    xfound <- ci[1]-sqrt(((total/2)^2)/(m2^2+1))
    xoff <- abs(ci[1]-xfound)
    xvals <- xoff*c(-1,1)+ci[1]
    ## this is the angle of the rectangle from the horizontal
    wsum <- c(0,cumsum(rects$wij))
    rate <- xoff/total*2
    ix <- function(w)w*rate+ci[1]-xoff
    jx <- function(w)w*rate+cj[1]-xoff
    for(k in 1:(length(wsum)-1)){
      IX <- c(ix(wsum[k]),ix(wsum[k+1]))
      JX <- c(jx(wsum[k+1]),jx(wsum[k]))
      m <- cbind(c(IX,JX),c(iperp(IX),jperp(JX)))
      row <- t(c(start=colMeans(m[c(1,4),]),end=colMeans(m[c(2,3),])))
      width <- rbind(width,data.frame(row,rect.num=k))
      ij <- with(rects,sprintf("%d%d",i[k],j[k]))
      ws <- rbind(ws,data.frame(alpha=t(colMeans(m)),
                                label=sprintf("\\tiny$w_{%s}$",ij)))
      polys <- rbind(polys,data.frame(alpha=m,rect.num=factor(k),
                    pair=ij,row.names=NULL))
    }
  }
  list(polys=polys,clusters=clusters,ws=ws,width=width)
}
idname <- "Identity weights, $t=\\Omega(X)$"
line.df <- data.frame(getlines(x),figure=factor(idname))
jointitle <- sprintf("Decreasing weights after join, $t<\\Omega(X)$")
apart <- "Decreasing weights, $t=\\Omega(X)$"
outside <- data.frame(start=rbind(x,x),figure=idname,
                      end.1=c(x[1,1],x[1,1],x[3,1],x[3,1],x[3,1],x[3,1]),
                      end.2=c(x[2,2],x[2,2],x[2,2],x[1,2],x[2,2],x[1,2]))
segs <- rbind(outside,line.df[,names(outside)])
getcenter <- function(d,ann,xoff=0,yoff=0){
  with(d,data.frame(x=(start.1+end.1)/2+xoff,y=(start.2+end.2)/2+yoff,
                    label=sprintf("\\scriptsize$\\ell_%s$",ann),
                    figure=idname))
}
inf <- getcenter(outside,"\\infty")[c(1,4,5),]
inf$y[1] <- inf$y[1]+0.2
inf$x[-1] <- inf$x[-1]+0.2
inf$y[3] <- inf$y[3]+0.1
norms <- rbind(getcenter(line.df,"2"),getcenter(outside,"1"),inf)
norms$y[6] <- norms$y[6]+0.05
norms$y[8] <- norms$y[8]+0.1
library(ggplot2)
theme_set(theme_bw())
@ 

<<fig=TRUE,tikz=TRUE,external=TRUE,echo=FALSE,results=hide,width=3,height=3.25>>=
## calculate this first to get proper scale
#path <- cvxmod.cluster(x,regularization.points=20)
#biggest <- path[path$s==1,]
#big.polys <- getpolys(biggest)
interpretation <- function(...){
  p <- ggplot(NULL,aes(alpha.1,alpha.2))+
    coord_equal()+
    scale_x_continuous("$\\alpha^1$",limits=c(-1.1,0.4),breaks=c(-10))+
    scale_y_continuous("$\\alpha^2$",limits=c(-1.3,0.6),breaks=c(-10))+
    geom_text(aes(label=label),
            data=data.frame(alpha.1=c(-1,x[2,1]-0.05,0.35),
              alpha.2=c(-1.25,0.35,x[3,2]),
              label=sprintf("\\scriptsize$X_%d$",1:3)))
    #geom_blank(data=big.polys$polys)
  L <- list(...)
  for(l in L)p <- p+l
  p+  geom_point(data=pts,pch=21,fill="white")
}
print(interpretation(
  geom_segment(aes(start.1,start.2,xend=end.1,yend=end.2),
               data=segs,lwd=2,colour="grey"),
  geom_text(aes(x,y,label=label),data=norms)
))
@ 
\end{minipage}

\end{frame}

<<results=hide,echo=FALSE,fig=FALSE>>=
path <- cvxmod.cluster(x,regularization.points=40)
plotpolys <- function(Slim){
  SVAL <- min(subset(path,s>=Slim)$s)
a <- path[path$s==SVAL,]
poly.list <- getpolys(a)
interpretation(
  geom_polygon(aes(group=interaction(pair,rect.num)),
               data=data.frame(poly.list$polys),
               fill="grey",colour="white",lwd=1.2),
  geom_segment(aes(start1,start2,xend=end1,yend=end2),
               data=data.frame(poly.list$width),
               colour="white"),
  geom_text(aes(label=label),data=data.frame(poly.list$ws)),
  geom_path(aes(group=row),data=data.frame(path),
            subset=.(s>=SVAL)),
               geom_point(data=data.frame(a))
                     )
}
@ 

ANIMATION(rects)

<<fig=FALSE,echo=FALSE,results=hide>>=
set.seed(19) 
sim <- gendata(N=5,D=2,K=2,SD=0.6)
## cvx <- data.frame()
## for(norm in c(1,2,"inf"))for(gamma in c(0,1)){
##   cvx <- rbind(cvx,cvxmod.cluster(sim$mat,norm=norm,gamma=gamma,
##                                   regularization.points=50))
## }
load(url("http://cbio.ensmp.fr/~thocking/clusterpath-figure-2.RData"))
means <- data.frame(alpha=t(colMeans(sim$mat)))
normweights <- function(var,val){
  val <- as.character(val)
  if(var=="gamma")var <- "\\gamma"
  else var <- sprintf("\\textrm{%s}",var)
  val[val=="inf"] <- "\\infty"
  sprintf("$%s=%s$",var,val)
}
plot.one <- function(S){
  path <- data.frame(subset(cvx,s>=S),points="$\\alpha$")
  alpha <- subset(path,s==min(s))
  xx <- alpha
  xx[,1] <- sim$mat[,1]
  xx[,2] <- sim$mat[,2]
  xx$points <- "$X$"
  xalpha <- rbind(alpha,xx)
ggplot(path,aes(alpha.2,alpha.1))+
  geom_path(aes(group=row),lwd=1)+
  facet_grid(gamma~norm,labeller=normweights)+
  coord_equal()+
  ##scale_colour_manual(values=c("$\\alpha$"="black","$X$"="blue"))+
  geom_point(data=xx,fill="white",pch=21)+
  scale_x_continuous("",breaks=-10)+
  scale_y_continuous("",breaks=-10)
}
@   

ANIMATION(panels)

\section{Algorithms proposed to solve the clusterpath}

\begin{frame}
  \frametitle{We propose dedicated solvers for each norm}
\begin{center}
\begin{tabular}{ccccc}
\hline
Norm & Properties & Algorithm &Complexity & Problem sizes \\
\hline
1 &piecewise linear&path&$O(pn\log n)$&large $\approx 10^5$  \\
 & separable\\
 &\\
2 &rotation invariant&active-set& $O(n^2p)$&medium $\approx10^3$ \\
&\\
$\infty$ & piecewise linear&Frank-Wolfe&unknown&medium $\approx 10^3$\\
\hline
\end{tabular}
\end{center}
\end{frame}

\begin{frame}
  \frametitle{An efficient path algorithm for the $\ell_1$ clusterpath}
  \begin{itemize}
\item Objective separable on each dimension $\alpha^i\in\RR^n$:
  $$\min_\alpha f_1(\alpha)= \sum_{k=1}^p\sum_{i=1}^n(X_{ik}-\alpha_{ik})^2
  +\lambda\sum_{i<j}|\alpha_{ik}-\alpha_{jk}|=\sum_{k=1}^p\min_{\alpha^i}f_1(\alpha_i)$$
\item Piecewise linearity.
\item LARS-like path-following algorithm (Hoefling \emph{et al.}\
  2009), checks for split of a cluster of size $n_C$ by solving a
  max-flow problem: $O(n_C^3)$.
\item \textbf{Theorem}: the $\ell_1$ clusterpath with $w_{ij}=1$ is strictly
  agglomerative, so no need to check for splits.
\item $n-1$ joins on each of $p$ dimensions. Each join only costs
  $O(\log n)$ using queues and linked lists: $O(pn\log n)$.
\item Exact solutions for the entire regularization path!
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The spectral clusterpath}
  2 possible problems with spectral clustering:
  \begin{itemize}
  \item Hard-thresholding of eigenvectors:\\
    $e_{01}(x)=1_{x\leq\Lambda}$ for some eigenvalue $\Lambda$.
  \item K-means on eigenvectors.
  \end{itemize}
  We propose:
  \begin{itemize}
  \item Soft-thresholding of eigenvectors:\\
    $e_{\exp}(x)=\exp(-\nu x)$ for some $\nu>0$.
  \item Clusterpath on the eigenvectors.
  \end{itemize}
\end{frame}

\section{Results and conclusions}

\begin{frame}
  \frametitle{Typical results for several clustering algorithms}
  \includegraphics[width=\textwidth]{moons}

  Weighted $\ell_2$ clusterpath with $\gamma=2$.
\end{frame}

\begin{frame}
  \frametitle{Performance and timings over several simulations}
\begin{tabular}{lrrrr}
\hline
  Clustering method & Rand & SD & Seconds & SD \\ 
  \hline
  $e_{\exp}$ spectral clusterpath & 0.99 & 0.00 & 8.49 & 2.64 \\ 
  $e_{\exp}$ spectral kmeans & 0.99 & 0.00 & 3.10 & 0.08 \\ 
  clusterpath & 0.95 & 0.12 & 29.47 & 2.31 \\ 
  $e_{01}$ Ng et al. kmeans & 0.95 & 0.19 & 7.37 & 0.42 \\ 
  $e_{01}$ spectral kmeans & 0.91 & 0.19 & 3.26 & 0.21 \\ 
  Gaussian mixture & 0.42 & 0.13 & 0.07 & 0.00 \\
  average linkage & 0.40 & 0.13 & 0.05 & 0.00 \\ 
  kmeans & 0.26 & 0.04 & 0.01 & 0.00 \\ 
  \hline
\end{tabular}

Performance measured using the Normalized Rand Index (Hubert and Arabie 1985).
\begin{itemize}
\item 0 means random assignment.
\item 1 means perfect correspondence, up to label permutation.
\end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Conclusions and future work}
  \begin{itemize}
  \item We proposed a new family of \alert<1>{convex} objective
    functions for clustering.
  \item Using $w_{ij}=1$ with the $\ell_1$ norm, we have
    \alert<1>{hierarchical} clustering and complexity $O(pn\log n)$.
\item \alert<1>{Performance} of weighted $\ell_2$ similar to spectral
  clustering.
\item Free, open-source R/C++/Python optimization software available:
  \url{http://clusterpath.r-forge.r-project.org}
\item Benefit of relaxing the eigenvector thresholding in spectral
  clustering. Generality?
\item Open question: hierarchical clusterpath for which other weights
  and norms?
\item Learning the weights and number of clusters automatically?
\end{itemize}
\only<2>{Thank you, any questions?}
\end{frame}

\end{document}
